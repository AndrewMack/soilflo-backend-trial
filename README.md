# SoilFLO Backend Trial

This project serves to demonstrate my (Andrew J. MacKenzie) abilities, as a coder, to take on the specs of a small project and fulfill them accurately and to completion. [Click here](https://github.com/SoilFLO/interview-takehome-be) to go to the original spec-sheet (repo) on GitHub.


## Questions For Clarity

As this is for an interview, I am of the understanding that we do not get the opportunity to ask questions for the sake of clarity. Therefore, I will pose my questions here, along with my assumption, to demonstrate where opportunities for correction may have been able to take place.

### Tickets do not have a Site-ID

##### Observation/Question

A *Ticket* represents work for a Truck to be moving Material. It was stated earlier that Material is either coming in or going out. If a Ticket is made for Material going out, should not the Ticket have its own `site_id` in order to declare the whereabouts of the Material going out?

It is also stated later that a *Ticket* represents (describes) a load of Material being dispatched off-site.

##### Assumption made to move forward

Keep it simple -- this allows us to make changes in the future quicker and easier in case the assumption is wrong. 

Therefore, since we have that description of what a *Ticket* represents, do not allow a *Ticket* to be assigned a *Site*. All Tickets in this Application represent a load of Material being dispatched off-site.

### Ticket Site-Counter

##### Observation/Question

> A ticket has a number that is incremented per site

First, a *Ticket* does not have a *Site*.

Next is the question of *when* should the increment occur ... which may also then ask the question of the meaing or purpose of this counter.

##### Assumption

The *Site* is pulled from the *Ticket's Truck*. That is easy to assume.

The description of this counter also seems to indicate that a *Site* may have many *Trucks* -- whether or not this truth is represented in the JSON data or not -- the schema allows for this and this requirement suggests this to be the case as well.

I will assume, for now, that this ticket counter is simply a way for a human-readable distinct identifier for sites and trucks to use to indicate into their respective systems when tickets/pieces-of-work are completed and that both the ticket-counter as well as the site's name will be used to accomplish this. Therefore, the dispatch time does not need to be taken into account when incrementing this value. ( I had wondered if maybe the increments should occur in orderance of the dispatch timestamps of the tickets of the site ... but I shall *not* go ahead with this idea )

### Ticket Material is Soil

##### Observation/Question

For this application, a *Ticket's Material* will always be *Soil* ... but why call it "Material" insteaad of just "Soil"? -- are there other Material Types?

##### Assumption

The wording makes it seem that perhaps we should be preparing for other types of Materials in the future -- maybe different types of soil.

Let's make sure we have a `Material` column in our `Tickets` table and while initially we will provide it a value of `Soil`, we will use enums our application that can be easily extended/added-to to allow future types of Materials. 

(It would be better to make a `Materials` table and FK-Ref it in the `Tickets` table -- but, keeping it simple, let's just use an enum for now)

### Should a *Ticket* have a *Site*?

##### Question/Observation

In the description of a *Ticket* there is no reference to one having a *Site* -- only a *Truck*.

However, just thinking things through -- a *Truck* could, in the future, be assigned to a different *Site*. It is likely that, once the work of a *Site* is complete, that a *Truck* is assigned to a new *Site*. 

... and a *Ticket* represents work completed. If someone wanted to ask about work done on a particualr *Site*, and that *Site* had been completed and the *Truck* had therefore been assigned to a new *Site*, there would be no way to get those *Tickets* unless the *Ticket* had a reference to the *Site*.

##### Assumption

We should include `site_id` to our `Tickets` table. We are not duplicating data, we need this information for the scenario described above.

## Setting up

At the Project's Root run `npm i ` to install our dependencies.

### Database

This application requires a Database to run with 3 tables defined: `sites` `trucks` and `tickets`.

Below you may find examples of these tables written for a Postgres database.

#### Sites

```sql
create table if not exists sites (
	id int not null generated by default as identity,
	name varchar(32) not null,
	address varchar(512) not null,
	description varchar(1024) not null,
  primary key (id)
)
```

#### Trucks

```sql
create table if not exists trucks (
	id int not null generated by default as identity,
	license varchar(32) not null unique,
	site_id integer not null,
	primary key (id),
	constraint fk_site
		foreign key (site_id)
		references sites(id)
)
```

#### Tickets

```sql
create table if not exists tickets (
	id int not null generated by default as identity,
	truck_id int not null,
	site_id int not null,
	material varchar(32) not null,
	dispatched_at timestamptz not null,
	site_counter int default 0 not null,
	primary key (id),
	constraint fk_truck
		foreign key (truck_id)
		references trucks(id),
	constraint fk_site
		foreign key (site_id)
		references sites(id)
)
```

## To-Do

### How does Sequelizer relations work?

I've worked with Sequelizer directly; however, for the sake of consistency and conformity with Nest-JS, I want to use and declare Entity Relationships correctly using their techniques and best-practices.

Temporarily, I will use the foreign-keys as primitive values/columns.

In the future, try to figure out how to declare these Relationships and access them the Nest-JS/Sequelize way!

### Pagination for our Controllers

We definitely would want this for `Sites` -- but can definitely see a need for this for `Trucks` and `Tickets` too!
